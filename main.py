import sys
from mpi4py import MPI
import numpy as np
import random
import time
import matplotlib.pyplot as plt
import os

import data
import operators
import linalg

# =========================================================================
# Please read the readme.info file in order to see how to run the mini-app
# =========================================================================

# process command line arguments
# generate the discretization object
def readcmdline(argv):
    
    if len(argv) < 5: 
            print("Usage: main nx ny nt t v", 
            "nx = number of gridpoints in x-directions",
            "ny = number of gridpoints in y-direction", 
            "nt = number of timesteps",
            "t = total time", 
            "-v = (optional) turn on verbose output",
            "-io = (optional) enable interactive output (python graphs) of the solution",
            "-po = (optional) enable printed output (png image) of the solution generated in current directory",
            "-pm = (optional) print the final solution (matrix) to a text file (.txt) in current directory",
            "-d d = (optional) d parameters (float)",
            "-r r = (optional) r parameters (float)",
            "-ic ic = (optional) points with initial diffusion values for manually specify the intial condition of the model", sep='\n')
            sys.exit(-1)  
    
    nx = int(argv[1])
    if nx < 1:
        print("nx must be positive integer")
        sys.exit(-1)
    
    ny = int(argv[2])
    if ny < 1:
        print("ny must be positive integer")
        sys.exit(-1)
    
    nt = int(argv[3])
    if ny < 1:
        print("nt must be positive integer")
        sys.exit(-1)

    t = float(argv[4])
    if t < 0:
        print("t must be positive real value")
        sys.exit(-1)

    if '-v' in argv:
        data.verbose_output = True

    if '-io' in argv:
        data.interactive_output = True

    if '-po' in argv:
        data.printed_output = True
    
    if '-pm' in argv:
        data.printed_matrix = True

    data.discretization.r = 1000.0 # R
    data.discretization.d = 1.0    # D
    
    if '-d' in argv:
        i = argv.index('-d')
        try:
            d = float(argv[i+1])
            assert (d > 0.0)
            data.discretization.d = d
        except:
            print("The value following -d must be a positive real value")
            sys.exit(-1)
    
    if '-r' in argv:
        i = argv.index('-r')
        try:
            r = float(argv[i+1])
            assert (r > 0.0)
            data.discretization.r = r
        except:
            print("The value following -r must be a positive real value")
            sys.exit(-1)

    data.discretization.nx = nx     # horizontal number of grid
    data.discretization.ny = ny     # vertical number of grid
    data.discretization.nt = nt     # timestep
    data.discretization.dt = t / nt # timestep sizes

    # distance between grid points
    # always assume lenght of 1 for x dimension
    data.discretization.dx = 1.0 / (nx - 1)

    # beta = R * delta(x^2)/D
    data.discretization.beta = data.discretization.r * (data.discretization.dx**2) / data.discretization.d
    # alpha = dx^2/(D*dt)
    data.discretization.alpha = (data.discretization.dx**2)/(data.discretization.d * data.discretization.dt)

    # custom initial condition
    if '-ic' in argv:
        i = argv.index('-ic')
        
        try:
            data.discretization.points = process_points(argv[i+1])
        except:
            print("Your input is badly formatted, it should be of the form: [xCoord,yCoord,sValue/xCoord,yCoord,sValue/...]", 
            "In one block, without white space", 
            "0 <= xCoord < nx",
            "0 <= yCoord < ny",
            "0 <= sValue <= 1", sep='\n')
            sys.exit(-1)
        
        data.custom_init = True

# clean director from files potentially generated by the mini-app
def clean_directory(rank): 
    
    if rank == 0:
        if os.path.exists("output.png"): os.remove("output.png") 
        if os.path.exists("output.bin"): os.remove("output.bin")
        if os.path.exists("output.txt"): os.remove("output.txt")

# process the input for the custom inital condition
def process_points(string):

    triples = string[1:len(string)-1].split('/')
    points_list = []
    
    for triple in triples:
        numbers = triple.split(',')
        t = [int(numbers[0]), int(numbers[1]), float(numbers[2])]
        assert(t[0] >= 0 and t[0] < data.discretization.nx)
        assert(t[1] >= 0 and t[1] < data.discretization.ny)
        assert(t[2] >= 0.0 and t[2] <= 1.0)
        points_list.append(t)

    return points_list

# main function
def main(argv):

    # MPI init
    comm = MPI.COMM_WORLD
    
    rank = comm.Get_rank()
    size = comm.Get_size()

    # discretization object
    data.discretization = data.Discretization()
    discretization = data.discretization
    
    # arguments processing
    readcmdline(argv)

    # remove old files generated by write_binary function 
    clean_directory(rank)
    comm.Barrier()

    # domain object (object per SubDomain)
    data.domain = data.SubDomain(rank, size, discretization, comm)
    domain = data.domain

    # redefine variables for shortening the code
    nx = domain.nx
    ny = domain.ny
    nt = discretization.nt

    # iteration parameters
    max_cg_iters     = 200
    max_newton_iters = 50
    tolerance     = 1.e-6

    # message of beginning
    if domain.rank == 0:
        print("========================================================================")
        print("Welcome to mini-stencil!")
        print("Version   :: Python 3 with MPI4Py: " + str(domain.size) + " MPI ranks")
        print("Mesh      :: " + str(discretization.nx) + " * " + str(discretization.ny) + " dx = " + str(discretization.dx))
        print("Iteration :: " + "CG " + str(max_cg_iters) + ", Newton " + str(max_newton_iters) + ", tolerance " + str(tolerance))
        print("========================================================================")
    
    # details of the cartesian division of the processors
    if domain.rank == 0: print("Cartesian division details for each processor (subdomain)\n")
    domain.print()
    
    if domain.rank == 0 and data.verbose_output: 
        print("========================================================================")
        print("Verbose output\n")

    # solution matrices
    # ny = ROW and nx = COLUMN (!! VERY IMPORTANT !!)
    data.x_new = np.zeros((ny, nx), dtype=np.float64)
    data.x_old = np.zeros((ny, nx), dtype=np.float64)
    
    # boundary vectors
    # initialized on 0 (dirichlet boundary condition)
    data.bndN = np.zeros((1, nx), dtype=np.float64)
    data.bndS = np.zeros((1, nx), dtype=np.float64)
    data.bndE = np.zeros((1, ny), dtype=np.float64)
    data.bndW = np.zeros((1, ny), dtype=np.float64)
    
    # buffer vectors for exchanging boundary information
    # they act as temporary dataholders for exchange
    data.buffN = np.zeros((1, nx), dtype=np.float64)
    data.buffS = np.zeros((1, nx), dtype=np.float64)
    data.buffE = np.zeros((1, ny), dtype=np.float64)
    data.buffW = np.zeros((1, ny), dtype=np.float64)

    # Ax = b with b being 0 in the initial condition
    b = np.zeros((ny, nx), dtype=np.float64)
    # solution for conjugate gradient function
    deltax = np.zeros((ny, nx), dtype=np.float64)

    # convergence
    if domain.rank == 0:
        con = np.zeros((0), dtype=np.float64) # convergence of the last iteration 
        res = np.empty((nt), dtype=np.float64) # residual of each timestep

    if (data.custom_init):
        
        for i in data.discretization.points:

            x = i[0]
            y = i[1]
            s = i[2]
            
            if (x >= (domain.startx - 1) and x <= (domain.endx - 1)
                and y >= (domain.starty - 1) and y <= (domain.endy - 1)):
                x -= (domain.startx - 1)
                y -= (domain.starty - 1)

                data.x_new[y, x] = s

    else: 
    
        # Default initial condition (!! PROPORTIONAL TO THE GRID SIZE !!) 
        # A circle of concentration 0.1 centred at (xdim/4, ydim/4) 
        # with radius no larger than 1/8 of both xdim and ydim
        # x lenght is always one while y lenght is variable depending on the dimensions
        xc = 1.0 / 4.0
        yc = (discretization.ny - 1) * discretization.dx / 4.0
        # min ensure that radius will be not larger than 1/8 of xdim or ydim
        radius = min(xc, yc) / 2.0 
        
        # Startx and starty begins artificially to count from 1 but it is actually 0
        for j in range(domain.starty-1, domain.endy):
            
            # (j - 1) displace the circle slightly on the upper right of the domain
            # instead of being in the corner
            y = (j) * discretization.dx
            
            for i in range(domain.startx-1, domain.endx):
                
                # (i - 1) displace the circle slightly on the upper right of the domain
                # instead of being in the corner
                x = (i) * discretization.dx

                # Test if grid point is inside circle
                # Actually the circle only lies in the (0, 0) domain
                if ((x - xc) * (x - xc) + (y - yc) * (y - yc)) < (radius * radius):
                    data.x_new[j - domain.starty + 1][i - domain.startx + 1] = 0.1

    # Start time before solving the system
    start_time = time.time()

    # Main timeloop
    for timestep in range(1, nt + 1):

        # x_old = x_new
        # get back the solution of previous timestep 
        # to compute the solution of the actual timestep
        data.x_old[:] = data.x_new 

        # new residual at each time step
        residual = 0.0
        converged = False
        
        # newton iterations used to solve a system of non linear equations
        it = 0
        for it in range (0, max_newton_iters):
        
            # we get b in Ax = b by using the diffusion function
            # b = f(x_n)
            operators.diffusion(data.x_new, b, timestep, it)
            
            # residual of newton methods
            residual = linalg.norm(b) 

            # for plotting convergence of the newton methods
            if domain.rank == 0 and timestep == nt: 
                con = np.append(con, residual)
           
            if residual < tolerance:
                converged = True
                break

            # solve linear system to get deltax
            # Ax = b where A is J(x) and x deltax (we already have b)
            # we have to calculate the Jacobian and then solve to get deltax
            # J(x) * deltax = f(x)
            cg_converged = False
            cg_converged = linalg.cg_solver(deltax, b, max_cg_iters, tolerance, cg_converged)
            
            # Check that the CG solver converged
            if not cg_converged: 
                break

            # x_new = x_new - deltax
            # deltax = f(x_n)/f'(x_n) = f(x_n) * J^-1(x) 
            # deltax got from cg_converged function
            data.x_new -= deltax

        # stats for printing results 
        data.iters_newton += it + 1

        # Verbose mode (output stats at each Newton iteration)
        if converged and data.verbose_output:
            print("Step " + str(timestep) + " required " + str(it) + " iterations for residual " + str(residual))

        if not converged:
            print("Step " + str(timestep) + " ERROR : nonlinear iterations failed to converge")
            break

        # final residual for a series of newton iteration for each timestep
        if domain.rank == 0:
            res[timestep-1] = residual
    
    # total computational time for getting the solution
    timespent = time.time() - start_time

    # Avoid polluating printed output
    time.sleep(0.2)

    # final results printed
    if(domain.rank == 0):
        print("--------------------------------------------------------------------------------")
        print("Simulation took " + str(timespent) + " seconds")
        print(str(data.iters_cg) + " conjugate gradient iterations, at rate of " + str(data.iters_cg/timespent) + " iters/second")
        print(str(data.iters_newton) + " newton iterations")
        print(str(data.flops_count) + " floating point operations")
        print("--------------------------------------------------------------------------------")
        print("Goodbye !")

    # write final solution to BIN file for visualization
    # wld way used in the old c version
    # wept and modified for showing how to write in one file with MPI
    if data.printed_output:
        filename = write_binary("output", data.x_old, domain, discretization)
        read_binary(filename, domain, discretization)
    
    # interactive visualization of the final solution
    # all the subdomains solutions are merged into one matrix using MPI
    if data.interactive_output or data.printed_matrix:
        
        # merged results from all subdomains
        result = merge_solution(discretization, domain)

        # print final matrix result in txt file
        if data.printed_matrix and domain.rank == 0:
            print("output.txt generated in current directory !")
            np.savetxt("./output.txt", result)

        # generate interactive visualization
        if data.interactive_output and domain.rank == 0:
            print("(Close the python interactive windows to stop the program.)")
            plot_solution(result)
            plot_all_residual(res, discretization)
            # plot_convergence(con)
            
# merged the resulting matrix from all subdomains to the root processor 0
# reconstitution of the full solution
def merge_solution(discretization, domain): 
    
    # Total nx and ny of the full grid
    tnx = discretization.nx 
    tny = discretization.ny

    if domain.rank != 0:
        info = np.array([domain.ny, domain.nx, domain.neighbour_east, domain.neighbour_north], dtype=np.int)
        domain.comm_cart.Send([info, MPI.INT], dest=0, tag=1)
        domain.comm_cart.Send([data.x_old, MPI.DOUBLE], dest=0, tag=2)

    # Upper left of cartesian topology
    if domain.rank == 0: 
        
        # Final result concatenated
        result = np.zeros((tny, tnx), dtype=np.float64)
        
        # Info of the domain currently processed
        # [row, column, neigh_east, neigh_north]
        info = np.empty((4), dtype=np.int) 
        
        # Append rank 0 subdomain
        result[0:domain.ny, 0:domain.nx] = data.x_old

        # while variables
        current_neighbour_north = domain.neighbour_north
        current_neighbour_east = domain.neighbour_east
        
        # inner while variables
        rd = 0 # row <=> y
        cd = 0 + domain.nx # column <=> x

        # checked
        while current_neighbour_east >= 0:
            
            domain.comm_cart.Recv([info, MPI.INT], source=current_neighbour_east, tag=1)
            sub_matrix = np.empty((info[0], info[1]), dtype=np.float64)
            domain.comm_cart.Recv([sub_matrix, MPI.DOUBLE], source=current_neighbour_east, tag=2)
            result[rd:rd+info[0], cd:cd+info[1]] = sub_matrix
            
            cd += info[1]
            current_neighbour_east = info[2]

        rd += domain.ny
        cd = 0

        while current_neighbour_north >= 0:

            domain.comm_cart.Recv([info, MPI.INT], source=current_neighbour_north, tag=1)
            sub_matrix = np.empty((info[0], info[1]), dtype=np.float64)
            domain.comm_cart.Recv([sub_matrix, MPI.DOUBLE], source=current_neighbour_north, tag=2)
            result[rd:rd+info[0], cd:cd+info[1]] = sub_matrix

            cd += info[1]
            current_neighbour_east = info[2]
            current_neighbour_north = info[3]
            while current_neighbour_east >= 0:
                domain.comm_cart.Recv([info, MPI.INT], source=current_neighbour_east, tag=1)
                sub_matrix = np.empty((info[0], info[1]), dtype=np.float64)
                domain.comm_cart.Recv([sub_matrix, MPI.DOUBLE], source=current_neighbour_east, tag=2)
                result[rd:rd+info[0], cd:cd+info[1]] = sub_matrix
            
                cd += info[1]
                current_neighbour_east = info[2]
            
            rd += info[0]
            cd = 0
    
        return result
    
    return None

# plot interactively the final solution
def plot_solution(solution):
    plt.subplot(1, 2, 1)
    graph = plt.contourf(solution, 12, alpha=.75, cmap='jet')
    plt.contour(solution, 12, colors='black', linewidths=0.1)
    cbar = plt.colorbar(graph)
    cbar.set_label('Diffusion value')
    plt.title('Contour plot of solution')       
        

# plot interactively the graph of convergence
def plot_convergence(con):
    sc = con.size 
    x_values = np.arange((sc), dtype=np.int)
    
    plt.subplot(1, 2, 2)
    plt.plot(x_values, con)
    plt.ylabel('Residual')
    plt.xlabel('Newton iteration')
    plt.title('Convergence of last timestep for rank 0')
    plt.show()

# plot interactively the graph of the final convergence for each timestep
def plot_all_residual(con, discretization): 
    x_values = np.arange((discretization.nt), dtype=np.int)
    
    plt.subplot(1, 2, 2)
    plt.plot(x_values, con)
    plt.ylabel('Residual')
    plt.xlabel('Timestep')
    plt.title('Last residual at each step')
    plt.show()

# writting the final solution into a file in bytes
# which is then read by the read_binary function
# to generate the printed output
def write_binary(filename, x, domain, discretization):
    
    file_handle = MPI.File.Open(domain.comm_cart, filename + ".bin", MPI.MODE_CREATE | MPI.MODE_WRONLY, MPI.INFO_NULL)
    
    ustart = [domain.startx-1, domain.starty-1]
    ucount = [domain.nx, domain.ny]
    dimuids = [discretization.nx, discretization.ny]

    # create a custom datatype for the subdomains array
    file_type = MPI.DOUBLE.Create_subarray(dimuids, ucount, ustart, MPI.ORDER_FORTRAN)

    # A new datatype has to be committed before being used
    file_type.Commit()

    # We give each process a different file view using MPI_File_set_view 
    # so that together, the processes lay out a series of blocks in the file, 
    # one block per process.
    file_handle.Set_view(0, MPI.DOUBLE, file_type, "native", MPI.INFO_NULL)

    # write in the view which has been set
    file_handle.Write_all(x.flatten(), None)

    file_type.Free()

    file_handle.Close()

    return filename

# function written originally by Jean M. Favre 05.2015
# modified and simplified by Gary on 04.2020 in order to make it compatible with python 3
# and the python implementation of the HPC PDE mini-app solver
def read_binary(filename, domain, discretization): 
    
    if domain.rank == 0:
    
        # read matrix from "output.bin"
        data = np.fromfile(filename + ".bin", dtype=np.double, count=discretization.nx * discretization.ny, sep='')
        data = data.reshape(discretization.ny, discretization.nx)

        print("Create " + filename + ".png from matrix " + str(data.shape) + " in current directory !")
        graph = plt.contourf(data, 12, alpha=.75, cmap='jet')
        plt.contour(data, 12, colors='black', linewidths=0.1)
        cbar = plt.colorbar(graph)
        cbar.set_label('Diffusion value')
        plt.title('Contour plot of solution')
        plt.savefig("./" + filename + ".png")

main(sys.argv)


